
module AudioV3 (
	// Inputs
	CLOCK_50,
	KEY, HEX0, HEX1, HEX2, HEX3, HEX4,

	AUD_ADCDAT,

	// Bidirectionals
	AUD_BCLK,
	AUD_ADCLRCK,
	AUD_DACLRCK,

	FPGA_I2C_SDAT,

	// Outputs
	AUD_XCK,
	AUD_DACDAT,

	FPGA_I2C_SCLK,
	SW
);

/*****************************************************************************
 *                           Parameter Declarations                          *
 *****************************************************************************/


/*****************************************************************************
 *                             Port Declarations                             *
 *****************************************************************************/
// Inputs
input				CLOCK_50;
input		[3:0]	KEY;
input		[3:0]	SW;

input				AUD_ADCDAT;

// Bidirectionals
inout				AUD_BCLK;
inout				AUD_ADCLRCK;
inout				AUD_DACLRCK;

inout				FPGA_I2C_SDAT;

// Outputs
output				AUD_XCK;
output				AUD_DACDAT;

output				FPGA_I2C_SCLK;

output [6:0] HEX0;
output [6:0] HEX1;
output [6:0] HEX2;
output [6:0] HEX3;
output [6:0] HEX4;

/*****************************************************************************
 *                 Internal Wires and Registers Declarations                 *
 *****************************************************************************/
// Internal Wires
wire				audio_in_available;
wire		[31:0]	left_channel_audio_in;
wire		[31:0]	right_channel_audio_in;
wire				read_audio_in;

wire				audio_out_allowed;
wire		[31:0]	left_channel_audio_out;
wire		[31:0]	right_channel_audio_out;
wire				write_audio_out;

// Internal Registers

//reg [18:0] delay_cnt;
//wire [18:0] delay;

reg [17:0] delay_cnt;
wire [17:0] delay;


//reg [18:0] delay_cnt2;
//wire [18:0] delay2;

reg snd;
//reg snd2;

//reg [15:0] freq;
//reg [18:0] octaveFreq;

//reg [15:0] freq2;

wire [17:0] audioFreq; // output of the ram
reg [21:0] beatCount;
reg [9:0] address;
wire reset = ~KEY[0];

testMif test(.address(address), .clock(CLOCK_50), .data(18'b0), .wren(1'b0), .q(audioFreq)); 
segments u1(.c0(SW[0]), .c1(SW[1]), .c2(SW[2]), .c3(SW[3]), 
	.HEX1(HEX0[0]),
	.HEX2(HEX0[1]),
	.HEX3(HEX0[2]),
	.HEX4(HEX0[3]),
	.HEX5(HEX0[4]),
	.HEX6(HEX0[5]),
	.HEX7(HEX0[6]);
hex_decoder h2(.hex_digit(delay[7:4]), .segments(HEX1));
hex_decoder h3(.hex_digit(delay[11:8]), .segments(HEX2));
hex_decoder h4(.hex_digit(delay[15:12]), .segments(HEX3));
hex_decoder h5(.hex_digit(delay[17:16]), .segments(HEX4));
// State Machine Registers

/*****************************************************************************
 *                         Finite State Machine(s)                           *
 *****************************************************************************/


/*****************************************************************************
 *                             Sequential Logic                              *
 *****************************************************************************/


always @(posedge CLOCK_50)
	if(delay_cnt == delay) begin
		delay_cnt <= 0;
		snd <= !snd;
	end else delay_cnt <= delay_cnt + 1;
	
//always @(posedge CLOCK_50)
//	if (delay_cnt2 == delay2) begin 
//		delay_cnt2 <= 0;
//		snd2 <= !snd2;
//	end else delay_cnt2 <= delay_cnt2 + 1;

always @(posedge CLOCK_50) begin
	if (beatCount <= 22'b1011111010111100001000) begin
		beatCount <= 22'b0;
		if (reset)
			address <= 0;
		if (address < 10'b1011011001)
			address <= address + 1;
	
	end
	else 
		beatCount <= beatCount + 1;
end
		

/*****************************************************************************
 *                            Combinational Logic                            *
 *****************************************************************************/

assign delay = audioFreq;

wire [31:0] sound = (SW == 0) ? 0 : snd ? 32'd10000000 : -32'd10000000;


assign read_audio_in			= audio_in_available & audio_out_allowed;

assign left_channel_audio_out	= left_channel_audio_in+sound;
assign right_channel_audio_out	= right_channel_audio_in+sound;
assign write_audio_out			= audio_in_available & audio_out_allowed;

/*****************************************************************************
 *                              Internal Modules                             *
 *****************************************************************************/

Audio_Controller Audio_Controller (
	// Inputs
	.CLOCK_50						(CLOCK_50),
	.reset						(~KEY[0]),

	.clear_audio_in_memory		(),
	.read_audio_in				(read_audio_in),
	
	.clear_audio_out_memory		(),
	.left_channel_audio_out		(left_channel_audio_out),
	.right_channel_audio_out	(right_channel_audio_out),
	.write_audio_out			(write_audio_out),

	.AUD_ADCDAT					(AUD_ADCDAT),

	// Bidirectionals
	.AUD_BCLK					(AUD_BCLK),
	.AUD_ADCLRCK				(AUD_ADCLRCK),
	.AUD_DACLRCK				(AUD_DACLRCK),


	// Outputs
	.audio_in_available			(audio_in_available),
	.left_channel_audio_in		(left_channel_audio_in),
	.right_channel_audio_in		(right_channel_audio_in),

	.audio_out_allowed			(audio_out_allowed),

	.AUD_XCK					(AUD_XCK),
	.AUD_DACDAT					(AUD_DACDAT)

);

avconf #(.USE_MIC_INPUT(1)) avc (
	.FPGA_I2C_SCLK					(FPGA_I2C_SCLK),
	.FPGA_I2C_SDAT					(FPGA_I2C_SDAT),
	.CLOCK_50					(CLOCK_50),
	.reset						(~KEY[0])
);

endmodule

module hex_decoder(hex_digit, segments);
    input [3:0] hex_digit;
    output reg [6:0] segments;
   
    always @(*)
        case (hex_digit)
            4'h0: segments = 7'b100_0000;
            4'h1: segments = 7'b111_1001;
            4'h2: segments = 7'b010_0100;
            4'h3: segments = 7'b011_0000;
            4'h4: segments = 7'b001_1001;
            4'h5: segments = 7'b001_0010;
            4'h6: segments = 7'b000_0010;
            4'h7: segments = 7'b111_1000;
            4'h8: segments = 7'b000_0000;
            4'h9: segments = 7'b001_1000;
            4'hA: segments = 7'b000_1000;
            4'hB: segments = 7'b000_0011;
            4'hC: segments = 7'b100_0110;
            4'hD: segments = 7'b010_0001;
            4'hE: segments = 7'b000_0110;
            4'hF: segments = 7'b000_1110;   
            default: segments = 7'h7f;
        endcase
endmodule

module segments (
	input c0,c1,c2,c3,
	output HEX1, HEX2, HEX3, HEX4, HEX5, HEX6, HEX7
);

	assign HEX1 = (~c0 & ~c1 & ~c2 & c3) | (~c0 & c1 & ~c2 & ~c3) | (c0 & ~c1 & c2 & c3) | (c0 & c1 & ~c2 & c3);
	assign HEX2 = (~c0 & c1 & c2 & c3) | (~c0 & c1 & c2 & ~c3) | (c0 & ~c1 & c2 & c3) | (c0 & c1 & ~c2 & ~c3) | (c0 & c1 & c2 & ~c3) | (c0 & c1 & c2 & c3);
	assign HEX3 = (~c0 & ~c1 & c2 & ~c3) | (c0 & c1 & ~c2 & ~c3) | (c0 & c1 & c2 & ~c3) | (c0 & c1 & c2 & c3);
	assign HEX4 = (~c0 & ~c1 & ~c2 & c3) | (~c0 & c1 & ~c2 & ~c3) | (~c0 & c1 & c2 & c3) | (c0 & ~c1 & c2 & ~c3) | (c0 & c1 & c2 & c3);
	assign HEX5 = (~c0 & ~c1 & ~c2 & c3) | (~c0 & ~c1 & c2 & c3) | (~c0 & c1 & ~c2 & ~c3) | (~c0 & c1 & ~c2 & c3) | (~c0 & c1 & c2 & c3) | (c0 & ~c1 & ~c2 & c3);
	assign HEX6 = (~c0 & ~c1 & ~c2 & c3) | (~c0 & ~c1 & c2 & ~c3) | (~c0 & ~c1 & c2 & c3) | (~c0 & c1 & c2 & c3) | (~c0 & ~c1 & c2 & ~c3);
	assign HEX7 = (~c0 & ~c1 & ~c2 & ~c3) | (~c0 & ~c1 & ~c2 & c3) | (~c0 & c1 & c2 & c3) | (~c0 & ~c1 & ~c2 & ~c3) | (c0 & c1 & ~c2 & ~c3);
	
endmodule 

